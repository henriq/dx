package handler

import (
	"fmt"
	"slices"
	"strings"

	"dx/internal/cli/output"
	"dx/internal/cli/progress"
	"dx/internal/core"
	"dx/internal/core/domain"
	"dx/internal/ports"
)

type BuildCommandHandler struct {
	configRepository         core.ConfigRepository
	scm                      ports.Scm
	containerImageRepository ports.ContainerImageRepository
}

func ProvideBuildCommandHandler(
	configRepository core.ConfigRepository,
	scm ports.Scm,
	containerImageRepository ports.ContainerImageRepository,
) BuildCommandHandler {
	return BuildCommandHandler{
		configRepository:         configRepository,
		scm:                      scm,
		containerImageRepository: containerImageRepository,
	}
}

func (h *BuildCommandHandler) Handle(services []string, selectedProfile string) error {
	var dockerImagesToBuild []domain.DockerImage
	var dockerImagesToPull []string

	configContext, err := h.configRepository.LoadCurrentConfigurationContext()
	if err != nil {
		return err
	}

	for _, service := range configContext.Services {
		if len(services) == 0 && !slices.Contains(service.Profiles, selectedProfile) {
			continue
		}

		if len(services) > 0 && !slices.ContainsFunc(services, func(s string) bool { return s == service.Name }) {
			continue
		}

		dockerImagesToBuild = append(dockerImagesToBuild, service.DockerImages...)
		dockerImagesToPull = append(dockerImagesToPull, service.RemoteImages...)
	}

	if len(dockerImagesToBuild) > 0 {
		slices.SortFunc(
			dockerImagesToBuild, func(a, b domain.DockerImage) int {
				return strings.Compare(a.Name, b.Name)
			},
		)

		output.PrintHeader("Building Docker images")
		fmt.Println()

		// Create progress tracker with repo/ref info
		imageNames := make([]string, len(dockerImagesToBuild))
		imageInfos := make([]string, len(dockerImagesToBuild))
		for i, img := range dockerImagesToBuild {
			imageNames[i] = img.Name
			if img.GitRepoPath != "" && img.GitRef != "" {
				imageInfos[i] = fmt.Sprintf("%s @ %s", img.GitRepoPath, img.GitRef)
			}
		}
		tracker := progress.NewTrackerWithInfoAndVerb(imageNames, imageInfos, "Building")
		tracker.Start()

		var buildErr error
		for i, image := range dockerImagesToBuild {
			tracker.StartItem(i)

			// Show dockerfile override note (only in non-TTY mode, TTY shows spinner)
			if image.DockerfileOverride != "" {
				output.PrintSecondary("Using inline Dockerfile from configuration")
			}

			// Download source
			if err := h.scm.Download(image.GitRepoPath, image.GitRef, image.Path); err != nil {
				tracker.CompleteItem(i, err)
				tracker.PrintItemComplete(i)
				buildErr = err
				break
			}

			// Build image
			if err := h.containerImageRepository.BuildImage(image); err != nil {
				tracker.CompleteItem(i, err)
				tracker.PrintItemComplete(i)
				buildErr = err
				break
			}

			tracker.CompleteItem(i, nil)
			tracker.PrintItemComplete(i)
		}

		tracker.Stop()

		if buildErr != nil {
			return buildErr
		}

		fmt.Println()
		output.PrintSuccess(fmt.Sprintf("Built %d Docker %s", len(dockerImagesToBuild), output.Plural(len(dockerImagesToBuild), "image", "images")))
		fmt.Println()
	}

	if len(dockerImagesToPull) > 0 {
		slices.Sort(dockerImagesToPull)

		output.PrintHeader("Pulling Docker images")
		fmt.Println()

		// Create progress tracker for pulls
		tracker := progress.NewTrackerWithVerb(dockerImagesToPull, "Pulling")
		tracker.Start()

		var pullErr error
		for i, image := range dockerImagesToPull {
			tracker.StartItem(i)

			if err := h.containerImageRepository.PullImage(image); err != nil {
				tracker.CompleteItem(i, err)
				tracker.PrintItemComplete(i)
				pullErr = err
				break
			}

			tracker.CompleteItem(i, nil)
			tracker.PrintItemComplete(i)
		}

		tracker.Stop()

		if pullErr != nil {
			return pullErr
		}

		fmt.Println()
		output.PrintSuccess(fmt.Sprintf("Pulled %d Docker %s", len(dockerImagesToPull), output.Plural(len(dockerImagesToPull), "image", "images")))
	}

	return nil
}
