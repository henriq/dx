package handler

import (
	"fmt"
	"slices"

	"dx/internal/cli/output"
	"dx/internal/cli/progress"
	"dx/internal/core"
	"dx/internal/core/domain"
	"dx/internal/ports"
)

type InstallCommandHandler struct {
	configRepository         core.ConfigRepository
	containerImageRepository ports.ContainerImageRepository
	containerOrchestrator    ports.ContainerOrchestrator
	devProxyManager          *core.DevProxyManager
	environmentEnsurer       core.EnvironmentEnsurer
	scm                      ports.Scm
}

func ProvideInstallCommandHandler(
	configRepository core.ConfigRepository,
	containerImageRepository ports.ContainerImageRepository,
	containerOrchestrator ports.ContainerOrchestrator,
	devProxyManager *core.DevProxyManager,
	environmentEnsurer core.EnvironmentEnsurer,
	scm ports.Scm,
) InstallCommandHandler {
	return InstallCommandHandler{
		configRepository:         configRepository,
		containerImageRepository: containerImageRepository,
		containerOrchestrator:    containerOrchestrator,
		devProxyManager:          devProxyManager,
		environmentEnsurer:       environmentEnsurer,
		scm:                      scm,
	}
}

func (h *InstallCommandHandler) Handle(services []string, selectedProfile string, skipDevProxy bool) error {
	err := h.environmentEnsurer.EnsureExpectedClusterIsSelected()
	if err != nil {
		return err
	}

	configContext, err := h.configRepository.LoadCurrentConfigurationContext()
	if err != nil {
		return err
	}

	// Collect services to install
	var servicesToInstall []domain.Service
	for _, service := range configContext.Services {
		if len(services) == 0 && !slices.Contains(service.Profiles, selectedProfile) {
			continue
		}

		if len(services) > 0 && !slices.ContainsFunc(services, func(s string) bool { return s == service.Name }) {
			continue
		}

		servicesToInstall = append(servicesToInstall, service)
	}

	// Build unified service list with dev-proxy first if needed
	hasDevProxy := !skipDevProxy
	totalItems := len(servicesToInstall)
	if hasDevProxy {
		totalItems++
	}

	if totalItems == 0 {
		return nil
	}

	output.PrintHeader("Installing services")
	fmt.Println()

	// Build names and infos for tracker
	names := make([]string, 0, totalItems)
	infos := make([]string, 0, totalItems)

	if hasDevProxy {
		names = append(names, "dev-proxy")
		infos = append(infos, "dx")
	}

	for _, svc := range servicesToInstall {
		names = append(names, svc.Name)
		infos = append(infos, "")
	}

	tracker := progress.NewTrackerWithInfoAndVerb(names, infos, "Installing")
	tracker.Start()

	currentIndex := 0

	// Install dev-proxy first if needed
	if hasDevProxy {
		tracker.StartItem(currentIndex)

		if err := h.devProxyManager.SaveConfiguration(); err != nil {
			tracker.CompleteItem(currentIndex, err)
			tracker.PrintItemComplete(currentIndex)
			tracker.Stop()
			return err
		}

		if err := h.devProxyManager.BuildDevProxy(); err != nil {
			tracker.CompleteItem(currentIndex, err)
			tracker.PrintItemComplete(currentIndex)
			tracker.Stop()
			return err
		}

		if err := h.devProxyManager.InstallDevProxy(); err != nil {
			tracker.CompleteItem(currentIndex, err)
			tracker.PrintItemComplete(currentIndex)
			tracker.Stop()
			return err
		}

		tracker.CompleteItem(currentIndex, nil)
		tracker.PrintItemComplete(currentIndex)
		currentIndex++
	}

	// Install user services
	for _, service := range servicesToInstall {
		tracker.StartItem(currentIndex)

		err := h.scm.Download(service.HelmRepoPath, service.HelmBranch, service.HelmPath)
		if err != nil {
			tracker.CompleteItem(currentIndex, err)
			tracker.PrintItemComplete(currentIndex)
			tracker.Stop()
			return err
		}

		if err = h.containerOrchestrator.InstallService(&service); err != nil {
			installErr := fmt.Errorf("failed to install service %s: %v", service.Name, err)
			tracker.CompleteItem(currentIndex, installErr)
			tracker.PrintItemComplete(currentIndex)
			tracker.Stop()
			return installErr
		}

		tracker.CompleteItem(currentIndex, nil)
		tracker.PrintItemComplete(currentIndex)
		currentIndex++
	}

	tracker.Stop()
	fmt.Println()
	output.PrintSuccess(fmt.Sprintf("Installed %d %s", totalItems, output.Plural(totalItems, "service", "services")))

	return nil
}
